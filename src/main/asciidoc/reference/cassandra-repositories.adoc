[[cassandra.repositories]]
= Cassandra repositories

[[cassandra-repo-intro]]
== Introduction

This chapter will point out the specialties for repository support for Cassandra. This builds on the core repository support explained in <<repositories>>. So make sure you've got a sound understanding of the basic concepts explained there.

[[cassandra-repo-usage]]
== Usage

To access domain entities stored in Cassandra you can leverage our sophisticated repository support that eases implementing those quite significantly. To do so, simply create an interface for your repository:

.Sample Person entity
====
[source,java]
----
@Table
public class Person {

  @Id
  private String id;
  private String firstname;
  private String lastname;

  // â€¦ getters and setters omitted
}
----
====

We have a quite simple domain object here. Note that it has a property named `id` of type `String`. The default serialization mechanism used in `CassandraTemplate` (which is backing the repository support) regards properties named id as row id.

.Basic repository interface to persist Person entities
====
[source]
----
public interface PersonRepository extends CrudRepository<Person, String> {

  // additional custom finder methods go here
}
----
====

Right now this interface simply serves typing purposes but we will add additional methods to it later. In your Spring configuration simply add

.General Cassandra repository Spring configuration
====
[source,xml]
----
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	   xmlns:cassandra="http://www.springframework.org/schema/data/cassandra"
	   xsi:schemaLocation="
		http://www.springframework.org/schema/data/cassandra
		http://www.springframework.org/schema/data/cassandra/spring-cassandra-1.0.xsd
		http://www.springframework.org/schema/beans
		http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
		">

    <cassandra:cluster port="9042"/>
    <cassandra:session keyspace-name="keyspaceName"/>

    <cassandra:mapping
            entity-base-packages="com.acme.*.entities">
    </cassandra:mapping>

    <cassandra:converter/>

    <cassandra:template/>

    <cassandra:repositories base-package="com.acme.*.entities"/>
</beans>
----
====

This namespace element will cause the base packages to be scanned for interfaces extending `CrudRepository` and create Spring beans for each of them found. By default the repositories will get a `CassandraTemplate` Spring bean wired that is called `cassandraTemplate`, so you only need to configure `cassandra-template-ref` explicitly if you deviate from this convention.

If you'd rather like to go with JavaConfig use the `@EnableCassandraRepositories` annotation. The annotation carries the very same attributes like the namespace element. If no base package is configured the infrastructure will scan the package of the annotated configuration class.

.JavaConfig for repositories
====
[source,java]
----
@Configuration
@EnableCassandraRepositories
class ApplicationConfig extends AbstractCassandraConfiguration {

  @Override
  protected String getKeyspaceName() {
    return "keyspace";
  }

  public String[] getEntityBasePackages() {
    return new String[] { "com.oreilly.springdata.cassandra" };
  }
}
----
====

As our domain repository extends `CrudRepository` it provides you with CRUD operations.
Working with the repository instance is just a matter of dependency injecting it into a client.


[[cassandradb.repositories.queries]]
== Query methods

[[cassandradb.repositories.queries.delete]]
=== Repository delete queries

[[cassandradb.repositories.misc]]
== Miscellaneous

[[cassandradb.repositories.misc.cdi-integration]]
=== CDI Integration

Instances of the repository interfaces are usually created by a container, which Spring is the most natural choice when working with Spring Data. Spring Data Cassandra ships with a custom CDI extension that allows using the repository abstraction in CDI environments. The extension is part of the JAR so all you need to do to activate it is dropping the Spring Data Cassandra JAR into your classpath. You can now set up the infrastructure by implementing a CDI Producer for the `CassandraTemplate`:

[source,java]
----
class CassandraTemplateProducer {

	@Produces
	@Singleton
	public Cluster createCluster() throws Exception {
		CassandraConnectionProperties properties = new CassandraConnectionProperties();

		Cluster cluster = Cluster.builder().addContactPoint(properties.getCassandraHost())
				.withPort(properties.getCassandraPort()).build();
		return cluster;
	}

	@Produces
	@Singleton
	public Session createSession(Cluster cluster) throws Exception {
		return cluster.connect();
	}

	@Produces
	@ApplicationScoped
	public CassandraOperations createCassandraOperations(Session session) throws Exception {

		MappingCassandraConverter cassandraConverter = new MappingCassandraConverter();

		CassandraAdminTemplate cassandraTemplate = new CassandraAdminTemplate(session, cassandraConverter);
		return cassandraTemplate;
	}

	public void close(@Disposes Session session) {
		session.close();
	}

	public void close(@Disposes Cluster cluster) {
		cluster.close();
	}
}
----

The Spring Data Cassandra CDI extension will pick up `CassandraOperations` available as CDI bean and create a proxy for a Spring Data repository whenever an bean of a repository type is requested by the container. Thus obtaining an instance of a Spring Data repository is a matter of declaring an `@Inject`-ed property:

[source,java]
----
class RepositoryClient {

  @Inject
  PersonRepository repository;

  public void businessMethod() {
    List<Person> people = repository.findAll();
  }
}
----
